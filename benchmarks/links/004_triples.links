sig choice : Comp(Bool, {Choice:(()) {}-> Bool|_})
fun choice() {do Choice(())}

sig fail : Comp(a, {Failure:(()) {}-> Zero|_})
fun fail() {switch (do Failure(())) { }}

sig choose : (Int) {Choice:(()) {}-> Bool,Failure:(()) {}-> Zero|a}~> Int
fun choose(n) {
    if (n < 1) {fail() }
    else if (choice()) { n }
    else { choose(n-1) }
}

sig triple : (Int, Int) -a-> () {Choice:(()) {}-> Bool,Failure:(()) {}-> Zero|b}~> (Int, Int, Int)
fun triple(n,s)(){
    var i = choose(n);
    var j = choose(i-1);
    var k = choose(j-1);
    if (i+j+k == s) {((i,j,k))}
    else {fail()}
}

sig hash_triple : (() -a-> (Int, Int, Int)) -b-> () -a-> Int
fun hash_triple(m)(){
    var (a,b,c) = m (); 
    mod((53 * a + 2809 * b + 148877 * c), 1000000007)
}

sig handler : (() {Choice:(()) {}-> Bool,Failure:(()) {}-> a::Any|b}~> Int) {Choice{c},Failure{d}|b}~> Int
fun handler(m) {
    handle(m()) {
        case Return(x) -> x
        case Choice((), k) -> mod((k(true) + k(false)), 1000000007)
        case Failure((), k) -> 0
    }
}

sig main : () {Choice{a},Failure{b}|c}~> ()
fun main(){
    var n = stringToInt(getArgs() !! 0);
    var s = stringToInt(getArgs() !! 1);
    var sum = handler(hash_triple(triple(n, s)));
    println(intToString(sum))
}

main()
